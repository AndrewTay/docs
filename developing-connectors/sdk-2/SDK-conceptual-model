---
title: Developer program
date: 2019-05-08 17:00:00 Z
---

[![Workato](/assets/images/workato_developer_program.png)](https://www.workato.com)

# Introduction
In Workato, we allow you to build custom connectors on our SDK using ruby (a coding language). Some basic coding knowledge in any language is recommended but ultimately, we believe our SDK (Software Development Kit) has been built such that users at any level of coding knowledge will be able to build custom connectors. The custom connectors you end up building can be used in any number of your recipes and you're also able to share them with your coworkers, friends or even the community at large.

By reading through our documentation, we will walk you through some fun basic examples to get you going before looking more closely at individual components of our SDK and how you can configure them just the way you want it.

Through out the whole process, you'll be able to build, test and push out your custom connector directly from Workato's SDK platform. This means working directly from the browser you have open right now and never having to install anything onto your computer. Pretty neat right?

Connector source code which you will write on the SDK platform will be hosted in Workato's servers and is executed whenever a recipe using that connector is triggered. Before we go any further, lets start with a quick overview of what a connector looks like when written in code.

## Overview
A custom connector on Workato always starts off with curly braces that encapsulates all code (Curly braces look like this `{}`). Inside the curly braces, this is where you'll be able to declare various objects which are basically the name of the object followed by another set of curly braces which encapsulates code related to that object. In the skeleton code below for example, all code related to my custom connector's connection will be written inside the object named `connection:`. This is the same for the other objects such as actions and triggers etc.

Take note that these names are strictly defined and must be spelt exactly for the Workato to know which object to reference when looking to authorise and perform an API request. Inside each object, there will be further nested objects that allow you to declare input fields for connections, actions and triggers which we will cover later on.

```ruby
{
  title: 'My sample connector',

  connection: { ... ),
  test: { ... },
  actions: { ... },
  triggers: { ... },
  object_definitions: ( ... },
  picklists: ( ... },
  methods: ( ... },
}
```

## SDK structure

- **title** - This is the name of your connector that will be displayed to end users. This is also be the title of the connector that users can search for your connector when searching for applications to make connections to.

- **connection** - This is where all connection configurations are stored for your custom connector. You will be able to declare the authentication type and input fields shown to the end user when they want to make a connection. We currently support basic, OAuth 2.0 natively as well as a custom authentication that allows you to connect to most other authentication types like digest and multi step authentication procedures.

- **test** - This is where you can define a test to ensure that your connection is still valid. This is used in cases like basic auth where we do a preliminary call when you first make a connection to let you know the connection was successful.

- **actions** - This is where you define actions that people using your custom connector can pick from after making a valid connection. You'll be able to define input fields for users to fill up as well as the exact mechanics of how the action handles data. Finally, you'll also be able to define the output schema of the action so that users can select these outputs for use in later steps.

- **triggers** - This is where you define triggers that people can use with your custom connector. Triggers kick start recipes and can either be implemented via polling (checking every few minutes) or webhooks (static or dynamic). Similar to actions, you'll be able to define user input fields and the machanics behind how the trigger is executed. Our triggers also provide closure maintenance and pagination capabilities, allowing you to design for users with heavy use cases.

- **object_definitions** - This is where you can define commonly used objects and reference them later on in your actions and triggers. Actions and triggers commonly reference these objects in input and output schema to reduce the amount of redundant code that you might have in your SDK. Object definitions are also able to make API requests - allowing you to access metadata whenever possible to generate dynamic input and output fields for users of your custom connector.

- **picklists** - This is where you can define lists of values. Reference them later on when you define input fields that are dropdowns instead of free text fields. Picklists can be static, dynamic based on API requests or even dependant on the previous input of the user.

- **methods** - This is where you can define functions in the same way that you would do in normal coding. Keep your code `DRY` by using methods. Methods can then be used in any object.

### Walkthrough
Now that we have a basic understanding of how a custom connector looks like code wise, lets start off by building a simple connector.

[### Walkthrough]()
